.. _luapp:

Luapp
======

Lua の C-API 関数で用いられている `lua_State` を C++ のクラスで
ラップしたもの． `lua_State` を第一引数として用いるほとんどの関数
と同様のメンバ関数を用意している．


Luapp で用いる列挙型
----------------------

メンバ関数の戻り値として用いられる `RetType`
という列挙型を定義している．

.. table::
   :align: left
   :widths: auto

   ============ =========================
   値           意味
   ============ =========================
   OK           正常終了
   ERROR        エラー
   NOT_FOUND    対象が見つからなかった．
   ============ =========================



コンストラクタ・デストラクタ
-----------------------------

通常は以下の形式で新しいオブジェクトを生成する．

::

   Luapp lua;


`lua` は内部で Lua インタプリタに関するリソースを管理する．
`lua` オブジェクトが破壊されたときに Lua インタプリタに関するリソース
も開放される．

Lua インタプリタに対してメモリアロケータなどの情報を渡す場合には以下の
ようにする．

::

   lua_Alloc f = ... // メモリアロケータ
   void* ud = ... // ユーザーデータ

   Luapp lua(f, ud);

この形式でも `lua` オブジェクトが破壊されると Lua インタプリタのリソー
スも開放される．

一方，すでに Lua インタプリタを生成している場合には以下の形式を用いる．

::

   lua_State* L = .. // Lua インタプリタのリソースを表すポインタ

   Luapp lua(L);


この形式の場合， `lua` が破壊されても `L` のリソースは開放されない．


基本的なスタック操作
----------------------

Lua の C-API は Lua インタプリタ上のスタックを介してデータのやり取りを
行う．
ただし，通常のスタックと異なり現在スタックに積まれている任意の要素を
アクセス可能である．
そのため，データを扱うためにはスタック上のインデックスを指定する
必要がある．通常，スタックのインデックスは1から始まり，最大値は現在の
スタックに積まれている要素数である．
ただし，負数を指定した場合にはスタックの先頭（最後にプッシュされた要素）
からの逆向きの位置となる．
さらに通常のスタックとは異なる領域に格納された upvalue という値もある
ため，見かけ上のインデックスを実際のインデックスに変換する必要がある．
そのための関数が `absindex()` である．

::

   int absindex(int idx)

通常のインデックスの場合は与えられた値をそのまま返す．
負数の場合にはスタックの底からの位置に変換して返す．
